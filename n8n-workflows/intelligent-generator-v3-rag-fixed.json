{
  "name": "Synthetic Data - Intelligent Generator V3 (RAG-Fixed)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-intelligent-v3-fixed",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "f94a2f25-4c38-4e2a-8739-d7345fdd2dc5",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "position": [
        -864,
        -176
      ],
      "webhookId": "generate-intelligent-v3-fixed-webhook",
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "user-prompt",
              "name": "query",
              "value": "={{ $json.body.chatInput || $json.body.prompt || $json.chatInput || $json.prompt }}",
              "type": "string"
            },
            {
              "id": "session-id",
              "name": "sessionId",
              "value": "={{ $json.body.sessionId || $json.sessionId || 'default-session' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-query",
      "name": "Extract Query",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [
        -672,
        -176
      ]
    },
    {
      "parameters": {
        "model": "llama3.2:latest"
      },
      "id": "embeddings-ollama",
      "name": "Embeddings Ollama",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        -480,
        32
      ],
      "credentials": {
        "ollamaApi": {
          "id": "jmFnQptmLMNT8nwD",
          "name": "Ollama account 2"
        }
      }
    },
    {
      "parameters": {
        "mode": "load",
        "qdrantCollection": {
          "__rl": true,
          "value": "successful_schemas",
          "mode": "name"
        },
        "prompt": "={{ $json.query }}",
        "options": {
          "topK": 3
        }
      },
      "id": "qdrant-search",
      "name": "Qdrant Vector Store",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1,
      "position": [
        -480,
        -176
      ],
      "credentials": {
        "qdrantApi": {
          "id": "3GkW3v6QuMuEQfVp",
          "name": "QdrantApi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build enhanced system message with retrieved schemas\nconst retrievedDocs = $input.all();\nconst webhookData = $('Webhook Trigger').item.json;\nconst userQuery = $('Extract Query').item.json.query;\n\nlet enhancedSystemMessage = \"You are a specialized synthetic data generator assistant. Your ONLY purpose is to help users generate test/dummy/sample data for various use cases.\\n\\nYOUR ROLE:\\n- Generate synthetic data for ANY use case requested by users\\n- Accept all requests related to data generation, datasets, records, or samples\\n- ONLY decline if asked completely unrelated questions\\n- If user mentions \\\"data\\\", \\\"create\\\", \\\"generate\\\", \\\"dataset\\\", \\\"records\\\" - IT'S A VALID REQUEST, process it!\\n\\nRESPONSE FORMAT (JSON only):\\n{\\n  \\\"message\\\": \\\"Brief explanation of what you're generating\\\",\\n  \\\"schema\\\": [\\n    {\\\"name\\\": \\\"field_name\\\", \\\"type\\\": \\\"field_type\\\"},\\n    ...\\n  ],\\n  \\\"recordCount\\\": number (max 1000)\\n}\\n\\n\";\n\n// Store retrieved schemas for data generator\nlet retrievedSchemas = [];\nlet schemasFound = 0;\nif (retrievedDocs && retrievedDocs.length > 0) {\n  enhancedSystemMessage += \"\\n\\nRELEVANT SCHEMA TEMPLATES FROM DATABASE:\\n\";\n  \n  retrievedDocs.forEach((item, index) => {\n    const json = item.json;\n    const doc = json.document || json;\n    const content = doc.pageContent || doc.metadata?.description || '';\n    const score = json.score || 0;\n    \n    if (content) {\n      schemasFound++;\n      const similarity = (score * 100).toFixed(0);\n      enhancedSystemMessage += `\\nTemplate ${index + 1} (${similarity}% relevant):\\n${content}\\n`;\n      \n      // Try to parse the schema from the content\n      try {\n        const schemaMatch = content.match(/\\[\\s*\\{[\\s\\S]*?\\}\\s*\\]/);\n        if (schemaMatch) {\n          const parsedSchema = JSON.parse(schemaMatch[0]);\n          if (Array.isArray(parsedSchema)) {\n            retrievedSchemas.push(...parsedSchema);\n          }\n        }\n      } catch (e) {\n        // Ignore parsing errors\n      }\n    }\n  });\n  \n  if (schemasFound > 0) {\n    enhancedSystemMessage += \"\\nUse these templates as reference and adapt to user's specific needs.\\n\";\n  }\n}\n\nenhancedSystemMessage += \"\\nBe intelligent, creative, and contextually aware. Design schemas that truly fit what users need!\";\n\nreturn [{\n  json: {\n    systemMessage: enhancedSystemMessage,\n    retrievedExamples: schemasFound,\n    retrievedSchemas: retrievedSchemas,\n    webhookData: webhookData.body,\n    userQuery: userQuery\n  }\n}];"
      },
      "id": "build-context",
      "name": "Build Enhanced System Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -176
      ]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Build Enhanced System Message').item.json.webhookData.sessionId || 'default-session' }}",
        "contextWindowLength": 10
      },
      "id": "chat-memory",
      "name": "Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        208,
        80
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('Build Enhanced System Message').item.json.userQuery }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "={{ $('Build Enhanced System Message').item.json.systemMessage }}"
        }
      },
      "id": "ai-agent",
      "name": "AI Agent (RAG-Enhanced)",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -64,
        -176
      ],
      "typeVersion": 1.8
    },
    {
      "parameters": {
        "model": "llama3.2:latest",
        "options": {
          "temperature": 0.7,
          "keepAlive": "1h",
          "numCtx": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        -112,
        96
      ],
      "id": "ollama-chat",
      "name": "Ollama Chat Model",
      "credentials": {
        "ollamaApi": {
          "id": "jmFnQptmLMNT8nwD",
          "name": "Ollama account 2"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response - extract first valid JSON object only\r\nconst aiOutput = $input.item.json.output || '';\r\nconst buildContext = $('Build Enhanced System Message').item.json;\r\n\r\nlet parsedResponse;\r\ntry {\r\n  let braceCount = 0;\r\n  let startIndex = -1;\r\n  let endIndex = -1;\r\n  \r\n  for (let i = 0; i < aiOutput.length; i++) {\r\n    if (aiOutput[i] === '{') {\r\n      if (braceCount === 0) startIndex = i;\r\n      braceCount++;\r\n    } else if (aiOutput[i] === '}') {\r\n      braceCount--;\r\n      if (braceCount === 0 && startIndex !== -1) {\r\n        endIndex = i;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  if (startIndex !== -1 && endIndex !== -1) {\r\n    const jsonStr = aiOutput.substring(startIndex, endIndex + 1);\r\n    parsedResponse = JSON.parse(jsonStr);\r\n    \r\n    if (!parsedResponse.schema || !Array.isArray(parsedResponse.schema)) {\r\n      throw new Error('Invalid schema format');\r\n    }\r\n    if (typeof parsedResponse.recordCount !== 'number') {\r\n      parsedResponse.recordCount = 100;\r\n    }\r\n  } else {\r\n    throw new Error('No JSON found in response');\r\n  }\r\n} catch (error) {\r\n  parsedResponse = {\r\n    message: \"I understood your request. Let me generate some sample data for you.\",\r\n    schema: [\r\n      {name: \"id\", type: \"uuid\"},\r\n      {name: \"name\", type: \"firstName\"},\r\n      {name: \"email\", type: \"email\"},\r\n      {name: \"created_at\", type: \"datetime\"}\r\n    ],\r\n    recordCount: 100\r\n  };\r\n}\r\n\r\n// CRITICAL FIX: Merge examples from retrieved schemas into the AI-generated schema!\r\nconst retrievedSchemas = buildContext.retrievedSchemas || [];\r\nif (retrievedSchemas.length > 0 && parsedResponse.schema) {\r\n  parsedResponse.schema = parsedResponse.schema.map(field => {\r\n    // Try to find a matching field in retrieved schemas by name\r\n    const matchingRetrieved = retrievedSchemas.find(rs => \r\n      rs.name && field.name && rs.name.toLowerCase() === field.name.toLowerCase()\r\n    );\r\n    \r\n    // If found and it has examples, MERGE THEM INTO THE SCHEMA!\r\n    if (matchingRetrieved && matchingRetrieved.examples && matchingRetrieved.examples.length > 0) {\r\n      return {\r\n        ...field,\r\n        examples: matchingRetrieved.examples,\r\n        description: matchingRetrieved.description || field.description\r\n      };\r\n    }\r\n    return field;\r\n  });\r\n}\r\n\r\nreturn [{\r\n  json: {\r\n    parsedResponse: parsedResponse,\r\n    originalOutput: aiOutput,\r\n    ragEnhanced: buildContext.retrievedExamples > 0,\r\n    schemasUsed: buildContext.retrievedExamples,\r\n    retrievedSchemas: retrievedSchemas\r\n  }\r\n}];\r\n\r\n"
      },
      "id": "response-parser",
      "name": "Response Parser",
      "type": "n8n-nodes-base.function",
      "position": [
        144,
        -176
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "functionCode": "// Enhanced data generator with RAG schema support\nconst parsedResponse = $input.item.json.parsedResponse;\nconst schema = parsedResponse.schema || [];\nconst recordCount = parsedResponse.recordCount || 100;\nconst message = parsedResponse.message || '';\nconst ragEnhanced = $input.item.json.ragEnhanced;\nconst schemasUsed = $input.item.json.schemasUsed;\nconst retrievedSchemas = $input.item.json.retrievedSchemas || [];\n\n// Enhanced generators with more realistic data\nconst generators = {\n  firstName: () => {\n    const names = ['James', 'Mary', 'John', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda', 'William', 'Elizabeth', 'David', 'Barbara', 'Richard', 'Susan', 'Joseph', 'Jessica', 'Thomas', 'Sarah', 'Christopher', 'Karen', 'Charles', 'Nancy', 'Daniel', 'Lisa', 'Matthew', 'Betty', 'Anthony', 'Helen', 'Mark', 'Sandra'];\n    return names[Math.floor(Math.random() * names.length)];\n  },\n  lastName: () => {\n    const names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Perez', 'Thompson', 'White', 'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson'];\n    return names[Math.floor(Math.random() * names.length)];\n  },\n  email: () => {\n    const first = generators.firstName().toLowerCase();\n    const last = generators.lastName().toLowerCase();\n    const domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'company.com'];\n    return `${first}.${last}@${domains[Math.floor(Math.random() * domains.length)]}`;\n  },\n  phone: () => {\n    const area = Math.floor(Math.random() * 900) + 100;\n    const prefix = Math.floor(Math.random() * 900) + 100;\n    const line = Math.floor(Math.random() * 9000) + 1000;\n    return `(${area}) ${prefix}-${line}`;\n  },\n  uuid: () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  },\n  datetime: () => {\n    const now = new Date();\n    const randomDays = Math.floor(Math.random() * 365);\n    const randomDate = new Date(now.getTime() + (randomDays * 24 * 60 * 60 * 1000));\n    return randomDate.toISOString();\n  },\n  date: () => {\n    const now = new Date();\n    const randomDays = Math.floor(Math.random() * 365);\n    const randomDate = new Date(now.getTime() + (randomDays * 24 * 60 * 60 * 1000));\n    return randomDate.toISOString().split('T')[0];\n  },\n  integer: () => Math.floor(Math.random() * 10000),\n  decimal: () => (Math.random() * 10000).toFixed(2),\n  amount: () => (Math.random() * 10000).toFixed(2),\n  creditCard: () => {\n    const parts = [];\n    for (let i = 0; i < 4; i++) {\n      parts.push(Math.floor(Math.random() * 9000) + 1000);\n    }\n    return parts.join('-');\n  },\n  boolean: () => Math.random() > 0.5,\n  string: () => {\n    const words = ['active', 'pending', 'completed', 'cancelled', 'processing', 'approved', 'rejected', 'draft', 'published', 'archived'];\n    return words[Math.floor(Math.random() * words.length)];\n  }\n};\n\n// Enhanced field value generation using retrieved schemas\nfunction generateIntelligentValue(fieldName, fieldType, retrievedSchemas) {\n  const nameLower = fieldName.toLowerCase();\n  \n  // First, try to find matching field in retrieved schemas\n  const matchingSchema = retrievedSchemas.find(schema => \n    schema.name && schema.name.toLowerCase().includes(nameLower.split('_')[0])\n  );\n  \n  if (matchingSchema && matchingSchema.examples && matchingSchema.examples.length > 0) {\n    // Use examples from retrieved schema\n    return matchingSchema.examples[Math.floor(Math.random() * matchingSchema.examples.length)];\n  }\n  \n  // CRITICAL: Check SPECIFIC patterns BEFORE generic ones!\n  \n  // Flight-specific fields (check FIRST before generic 'number' check!)\n  if (nameLower.includes('flight_number') || nameLower.includes('flight_no') || nameLower.includes('flightnumber')) {\n    const airlines = ['AA', 'UA', 'DL', 'WN', 'B6', 'NK', 'F9', 'AS', 'HA', 'VX'];\n    const airline = airlines[Math.floor(Math.random() * airlines.length)];\n    const flightNum = Math.floor(Math.random() * 9999) + 1;\n    return `${airline}${flightNum}`;\n  }\n  \n  if (nameLower.includes('airport') || nameLower.includes('airport_code')) {\n    const airports = ['LAX', 'JFK', 'ORD', 'DFW', 'DEN', 'ATL', 'SFO', 'SEA', 'LAS', 'MIA', 'PHX', 'IAH', 'MCO', 'BOS', 'DTW', 'MSP', 'PHL', 'LGA', 'BWI', 'DCA'];\n    return airports[Math.floor(Math.random() * airports.length)];\n  }\n  \n  if (nameLower.includes('airline') || nameLower.includes('carrier')) {\n    const airlines = ['AA', 'UA', 'DL', 'WN', 'B6', 'NK', 'F9', 'AS', 'HA', 'VX'];\n    return airlines[Math.floor(Math.random() * airlines.length)];\n  }\n  \n  if (nameLower.includes('seat')) {\n    const rows = Math.floor(Math.random() * 50) + 1;\n    const seats = ['A', 'B', 'C', 'D', 'E', 'F'];\n    const seat = seats[Math.floor(Math.random() * seats.length)];\n    return `${rows}${seat}`;\n  }\n  \n  if (nameLower.includes('flight_status') || nameLower.includes('booking_status')) {\n    const statuses = ['confirmed', 'pending', 'cancelled', 'completed', 'delayed', 'boarding', 'departed', 'arrived'];\n    return statuses[Math.floor(Math.random() * statuses.length)];\n  }\n  \n  // Generic field patterns (check AFTER specific ones)\n  if (nameLower.includes('id')) return generators.uuid();\n  if (nameLower.includes('name')) return generators.firstName() + ' ' + generators.lastName();\n  if (nameLower.includes('email')) return generators.email();\n  if (nameLower.includes('phone')) return generators.phone();\n  if (nameLower.includes('amount') || nameLower.includes('price') || nameLower.includes('fare')) return generators.amount();\n  if (nameLower.includes('date') || nameLower.includes('time')) return generators.datetime();\n  if (nameLower.includes('card')) return generators.creditCard();\n  if (nameLower.includes('status')) return generators.string();\n  if (nameLower.includes('count') || nameLower.includes('number') || nameLower.includes('passenger')) return generators.integer();\n  if (nameLower.includes('active') || nameLower.includes('enabled')) return generators.boolean();\n  \n  // Generic fallback\n  return generators[fieldType] ? generators[fieldType]() : generators.string();\n}\n\nlet data = [];\nfor (let i = 0; i < Math.min(recordCount, 1000); i++) {\n  const record = {};\n  schema.forEach(field => {\n    // ALWAYS use intelligent generation - it checks RAG examples AND has smart fallbacks!\n    record[field.name] = generateIntelligentValue(field.name, field.type, retrievedSchemas);\n  });\n  data.push(record);\n}\n\nreturn [{\n  json: {\n    response: {\n      message: message,\n      data: data,\n      recordCount: data.length,\n      rag_enhanced: ragEnhanced,\n      schemas_used: schemasUsed\n    }\n  }\n}];\n"
      },
      "id": "data-generator",
      "name": "Data Generator (RAG)",
      "type": "n8n-nodes-base.function",
      "position": [
        336,
        -176
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO chat_logs (session_id, user_prompt, ai_message, generated_schema, generated_data_sample, record_count, success, error_message, user_agent)\nVALUES (\n  'rag-session',\n  'flight booking request',\n  '{{ $json.response.message.replace(/'/g, \"''\") }}',\n  '{{ JSON.stringify($('Response Parser').item.json.parsedResponse.schema) }}',\n  '{{ JSON.stringify($json.response.data.slice(0, 3)) }}',\n  {{ $json.response.recordCount }},\n  true,\n  NULL,\n  'rag-workflow-fixed'\n)\nRETURNING id;",
        "options": {}
      },
      "id": "save-log",
      "name": "Save Chat Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        544,
        -176
      ],
      "credentials": {
        "postgres": {
          "id": "Qj2oredMBiLhvTqE",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Feedback Loop: Store successful schemas back to Qdrant for continuous learning\nconst response = $input.item.json.response;\nconst parsedResponse = $('Response Parser').item.json.parsedResponse;\nconst query = $('Extract Query').item.json.query;\n\n// Only store if RAG was enhanced and generation was successful\nif (!response.rag_enhanced || !parsedResponse.schema || parsedResponse.schema.length === 0) {\n  // Skip storage, just return the response as-is\n  return [$input.item];\n}\n\n// Extract domain/topic from the user's query or message\nconst domainName = parsedResponse.message || query.substring(0, 50);\n\n// Create rich schema text with examples for embedding\nconst schemaText = parsedResponse.schema.map(field => {\n  const parts = [\n    `${field.name} (${field.type})`,\n    field.description || '',\n    field.examples ? `Examples: ${field.examples.join(', ')}` : ''\n  ].filter(p => p);\n  return parts.join(' - ');\n}).join('\\n');\n\nconst fullDocument = `Domain: ${domainName}\\nUser Query: ${query}\\n\\nSchema:\\n${schemaText}`;\n\ntry {\n  // Generate embedding using Ollama\n  const embeddingResponse = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'http://host.docker.internal:11434/api/embeddings',\n    body: {\n      model: 'nomic-embed-text',\n      prompt: fullDocument\n    },\n    json: true\n  });\n\n  const embedding = embeddingResponse.embedding;\n\n  // Store in Qdrant\n  await this.helpers.httpRequest({\n    method: 'PUT',\n    url: 'http://host.docker.internal:6333/collections/successful_schemas/points',\n    body: {\n      points: [{\n        id: Date.now(),\n        vector: embedding,\n        payload: {\n          domain: domainName,\n          userQuery: query,\n          schema: parsedResponse.schema,\n          fieldCount: parsedResponse.schema.length,\n          timestamp: new Date().toISOString(),\n          source: 'user_interaction',\n          fullText: fullDocument\n        }\n      }]\n    },\n    json: true\n  });\n  \n  console.log('Successfully stored schema in Qdrant for:', domainName);\n} catch (error) {\n  console.log('Error storing in Qdrant:', error.message);\n  // Don't fail the workflow, just log the error\n}\n\n// Return the original response unchanged\nreturn [$input.item];"
      },
      "id": "feedback-loop",
      "name": "Feedback Loop - Store to Qdrant",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -176
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Data Generator (RAG)').item.json }}",
        "options": {}
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [
        736,
        -176
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "jsCode": "// Prepare successful schema for feedback to Qdrant\nconst response = $input.item.json.response;\nconst parsedResponse = $('Response Parser').item.json.parsedResponse;\nconst query = $('Extract Query').item.json.query;\n\n// Only store if RAG was enhanced and generation was successful\nif (response.rag_enhanced && response.schemas_used > 0 && parsedResponse.schema) {\n  // Create a rich text document from the schema\n  const schemaText = parsedResponse.schema.map(field => {\n    const parts = [\n      `Field: ${field.name}`,\n      `Type: ${field.type}`,\n      field.description ? `Description: ${field.description}` : '',\n      field.examples ? `Examples: ${field.examples.join(', ')}` : ''\n    ].filter(p => p);\n    return parts.join(' | ');\n  }).join('\\n');\n  \n  const fullText = `Domain: ${parsedResponse.message || 'Generated Schema'}\\nUser Query: ${query}\\n\\nSchema Fields:\\n${schemaText}`;\n  \n  return [{\n    json: {\n      pageContent: fullText,\n      metadata: {\n        domain: parsedResponse.message || 'generated',\n        userQuery: query,\n        fieldCount: parsedResponse.schema.length,\n        timestamp: new Date().toISOString(),\n        source: 'user_interaction'\n      },\n      schema: parsedResponse.schema\n    }\n  }];\n}\n\n// If not RAG-enhanced or failed, skip storage\nreturn [];"
      },
      "id": "prepare-schema-storage",
      "name": "Prepare Schema for Storage",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -176
      ]
    },
    {
      "parameters": {
        "mode": "insert",
        "qdrantCollection": {
          "__rl": true,
          "value": "successful_schemas",
          "mode": "name"
        },
        "options": {}
      },
      "id": "store-in-qdrant",
      "name": "Store Schema in Qdrant",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1,
      "position": [
        736,
        -176
      ],
      "credentials": {
        "qdrantApi": {
          "id": "3GkW3v6QuMuEQfVp",
          "name": "QdrantApi account"
        }
      }
    },
    {
      "parameters": {},
      "id": "document-loader",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        736,
        -24
      ]
    },
    {
      "id": "feedback-loop",
      "name": "Feedback Loop - Store to Qdrant",
      "typeVersion": 2,
      "parameters": {
        "functionCode": "// Feedback Loop: Store successful schemas back to Qdrant for continuous learning\r\nconst response = $input.item.json.response;\r\nconst parsedResponse = $('Response Parser').item.json.parsedResponse;\r\nconst query = $('Extract Query').item.json.query;\r\n\r\n// Only store if RAG was enhanced and generation was successful\r\nif (!response.rag_enhanced || !parsedResponse.schema || parsedResponse.schema.length === 0) {\r\n  // Skip storage, just return the response as-is\r\n  return [$input.item];\r\n}\r\n\r\n// Extract domain/topic from the user's query or message\r\nconst domainName = parsedResponse.message || query.substring(0, 50);\r\n\r\n// Create rich schema text with examples for embedding\r\nconst schemaText = parsedResponse.schema.map(field => {\r\n  const parts = [\r\n    `${field.name} (${field.type})`,\r\n    field.description || '',\r\n    field.examples ? `Examples: ${field.examples.join(', ')}` : ''\r\n  ].filter(p => p);\r\n  return parts.join(' - ');\r\n}).join('\\n');\r\n\r\nconst fullDocument = `Domain: ${domainName}\\nUser Query: ${query}\\n\\nSchema:\\n${schemaText}`;\r\n\r\n// Generate embedding using Ollama\r\nconst embeddingResponse = await this.helpers.httpRequest({\r\n  method: 'POST',\r\n  url: 'http://host.docker.internal:11434/api/embeddings',\r\n  body: {\r\n    model: 'nomic-embed-text',\r\n    prompt: fullDocument\r\n  },\r\n  json: true\r\n});\r\n\r\nconst embedding = embeddingResponse.embedding;\r\n\r\n// Store in Qdrant\r\nconst qdrantResponse = await this.helpers.httpRequest({\r\n  method: 'PUT',\r\n  url: 'http://host.docker.internal:6333/collections/successful_schemas/points',\r\n  body: {\r\n    points: [{\r\n      id: Date.now(),\r\n      vector: embedding,\r\n      payload: {\r\n        domain: domainName,\r\n        userQuery: query,\r\n        schema: parsedResponse.schema,\r\n        fieldCount: parsedResponse.schema.length,\r\n        timestamp: new Date().toISOString(),\r\n        source: 'user_interaction',\r\n        fullText: fullDocument\r\n      }\r\n    }]\r\n  },\r\n  json: true\r\n});\r\n\r\nconsole.log('Stored schema in Qdrant:', qdrantResponse);\r\n\r\n// Return the original response unchanged\r\nreturn [$input.item];\r\n\r\n"
      },
      "type": "n8n-nodes-base.code",
      "position": [
        544,
        -176
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Query": {
      "main": [
        [
          {
            "node": "Qdrant Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama": {
      "ai_embedding": [
        [
          {
            "node": "Qdrant Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ],
        {
          "index": 0,
          "node": "Store Schema in Qdrant",
          "type": "ai_embedding"
        }
      ]
    },
    "Qdrant Vector Store": {
      "main": [
        [
          {
            "node": "Build Enhanced System Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Enhanced System Message": {
      "main": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent (RAG-Enhanced)": {
      "main": [
        [
          {
            "node": "Response Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Response Parser": {
      "main": [
        [
          {
            "node": "Data Generator (RAG)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Generator (RAG)": {
      "main": [
        [
          {
            "node": "Feedback Loop - Store to Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Feedback Loop - Store to Qdrant": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "528341b2e86c53477b94f918c416779dab805188fc81ebe05aeea5067b309de6"
  }
}
