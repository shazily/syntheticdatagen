{
  "name": "Synthetic Data - Intelligent Generator V3 (RAG-Fixed)",
  "nodes": [
    {
      "id": "f94a2f25-4c38-4e2a-8739-d7345fdd2dc5",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-intelligent-v3-learn",
        "responseMode": "responseNode",
        "options": {}
      },
      "position": [
        -864,
        -176
      ],
      "typeVersion": 1.1,
      "credentials": null,
      "webhookId": "generate-intelligent-v3-fixed-webhook"
    },
    {
      "id": "extract-query",
      "name": "Extract Query",
      "type": "n8n-nodes-base.set",
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "user-prompt",
              "name": "query",
              "value": "={{ $json.body.chatInput || $json.body.prompt || $json.chatInput || $json.prompt }}",
              "type": "string"
            },
            {
              "id": "session-id",
              "name": "sessionId",
              "value": "={{ $json.body.sessionId || $json.sessionId || 'default-session' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "position": [
        -672,
        -176
      ],
      "typeVersion": 3.3,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "generate-embedding",
      "name": "Generate Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/embeddings",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"model\": \"llama3.2:latest\", \"prompt\": $json.query } }}",
        "options": {}
      },
      "position": [
        -480,
        -176
      ],
      "typeVersion": 4.2,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "search-qdrant",
      "name": "Search Qdrant",
      "type": "n8n-nodes-qdrant.qdrant",
      "parameters": {
        "resource": "search",
        "operation": "queryPoints",
        "collectionName": "successful_schemas",
        "vector": "={{ $json.embedding }}",
        "limit": 4,
        "withPayload": true,
        "options": {}
      },
      "position": [
        -272,
        -176
      ],
      "typeVersion": 1,
      "credentials": {
        "qdrantRestApi": {
          "id": "xK9MWIBpqQIgQmbC",
          "name": "Qdrant account"
        }
      },
      "webhookId": null
    },
    {
      "id": "build-context",
      "name": "Build Enhanced System Message",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "const qdrantResponse = $input.item.json;\nconst webhookData = $('Webhook Trigger').item.json;\nconst userQuery = $('Extract Query').item.json.query;\n\nlet enhancedSystemMessage = \"You are a specialized synthetic data generator assistant. Your ONLY purpose is to help users generate test/dummy/sample data for various use cases.\\n\\nYOUR ROLE:\\n- Generate synthetic data for ANY use case requested by users\\n- Accept all requests related to data generation, datasets, records, or samples\\n- ONLY decline if asked completely unrelated questions\\n- If user mentions \\\"data\\\", \\\"create\\\", \\\"generate\\\", \\\"dataset\\\", \\\"records\\\" - IT'S A VALID REQUEST, process it!\\n\\nRESPONSE FORMAT (JSON only):\\n{\\n  \\\"message\\\": \\\"Brief explanation of what you're generating\\\",\\n  \\\"schema\\\": [\\n    {\\\"name\\\": \\\"field_name\\\", \\\"type\\\": \\\"field_type\\\"},\\n    ...\\n  ],\\n  \\\"recordCount\\\": number (max 1000)\\n}\\n\\n\";\n\nlet retrievedSchemas = [];\nlet schemasFound = 0;\n\nconst qdrantResults = qdrantResponse.result || [];\n\nif (qdrantResults.length > 0) {\n  enhancedSystemMessage += \"\\n\\nRELEVANT SCHEMA TEMPLATES FROM DATABASE:\\n\";\n  \n  qdrantResults.forEach((result, index) => {\n    const payload = result.payload || {};\n    const score = result.score || 0;\n    const domain = payload.domain || 'Unknown';\n    const schemaStr = payload.schema || '';\n    const description = payload.description || '';\n    const text = payload.text || '';\n    \n    schemasFound++;\n    const similarity = (score * 100).toFixed(0);\n    \n    enhancedSystemMessage += `\\nTemplate ${index + 1} (${similarity}% match): ${domain}\\n`;\n    if (description) enhancedSystemMessage += `Description: ${description}\\n`;\n    \n    try {\n      const parsedSchema = JSON.parse(schemaStr);\n      if (Array.isArray(parsedSchema)) {\n        retrievedSchemas.push(...parsedSchema);\n        enhancedSystemMessage += `Fields: ${parsedSchema.map(f => f.name).join(', ')}\\n`;\n      }\n    } catch (e) {\n      console.log('Schema parse error:', e.message);\n    }\n  });\n  \n  if (schemasFound > 0) {\n    enhancedSystemMessage += \"\\nUse these templates as reference and adapt to user's specific needs.\\n\";\n  }\n} else {\n  console.log('No schemas retrieved from Qdrant');\n}\n\nenhancedSystemMessage += \"\\nBe intelligent, creative, and contextually aware. Design schemas that truly fit what users need!\";\n\nreturn [{\n  json: {\n    systemMessage: enhancedSystemMessage,\n    retrievedExamples: schemasFound,\n    retrievedSchemas: retrievedSchemas,\n    webhookData: webhookData.body,\n    userQuery: userQuery\n  }\n}];"
      },
      "position": [
        -272,
        -176
      ],
      "typeVersion": 2,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "chat-memory",
      "name": "Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Build Enhanced System Message').item.json.webhookData.sessionId || 'default-session' }}",
        "contextWindowLength": 10
      },
      "position": [
        208,
        80
      ],
      "typeVersion": 1.3,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "ai-agent",
      "name": "AI Agent (RAG-Enhanced)",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "parameters": {
        "promptType": "define",
        "text": "={{ $('Build Enhanced System Message').item.json.userQuery }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "={{ $('Build Enhanced System Message').item.json.systemMessage }}"
        }
      },
      "position": [
        -64,
        -176
      ],
      "typeVersion": 1.8,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "ollama-chat",
      "name": "Ollama Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "parameters": {
        "model": "llama3.2:latest",
        "options": {
          "temperature": 0.7,
          "keepAlive": "1h",
          "numCtx": 2048
        }
      },
      "position": [
        -112,
        96
      ],
      "typeVersion": 1,
      "credentials": {
        "ollamaApi": {
          "id": "jmFnQptmLMNT8nwD",
          "name": "Ollama account 2"
        }
      },
      "webhookId": null
    },
    {
      "id": "response-parser",
      "name": "Response Parser",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "// Parse AI response - extract first valid JSON object only\r\nconst aiOutput = $input.item.json.output || '';\r\nconst buildContext = $('Build Enhanced System Message').item.json;\r\n\r\nlet parsedResponse;\r\ntry {\r\n  let braceCount = 0;\r\n  let startIndex = -1;\r\n  let endIndex = -1;\r\n  \r\n  for (let i = 0; i < aiOutput.length; i++) {\r\n    if (aiOutput[i] === '{') {\r\n      if (braceCount === 0) startIndex = i;\r\n      braceCount++;\r\n    } else if (aiOutput[i] === '}') {\r\n      braceCount--;\r\n      if (braceCount === 0 && startIndex !== -1) {\r\n        endIndex = i;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  if (startIndex !== -1 && endIndex !== -1) {\r\n    const jsonStr = aiOutput.substring(startIndex, endIndex + 1);\r\n    parsedResponse = JSON.parse(jsonStr);\r\n    \r\n    if (!parsedResponse.schema || !Array.isArray(parsedResponse.schema)) {\r\n      throw new Error('Invalid schema format');\r\n    }\r\n    if (typeof parsedResponse.recordCount !== 'number') {\r\n      parsedResponse.recordCount = 100;\r\n    }\r\n  } else {\r\n    throw new Error('No JSON found in response');\r\n  }\r\n} catch (error) {\r\n  parsedResponse = {\r\n    message: \"I understood your request. Let me generate some sample data for you.\",\r\n    schema: [\r\n      {name: \"id\", type: \"uuid\"},\r\n      {name: \"name\", type: \"firstName\"},\r\n      {name: \"email\", type: \"email\"},\r\n      {name: \"created_at\", type: \"datetime\"}\r\n    ],\r\n    recordCount: 100\r\n  };\r\n}\r\n\r\n// CRITICAL FIX: Merge examples from retrieved schemas into the AI-generated schema!\r\nconst retrievedSchemas = buildContext.retrievedSchemas || [];\r\nif (retrievedSchemas.length > 0 && parsedResponse.schema) {\r\n  parsedResponse.schema = parsedResponse.schema.map(field => {\r\n    // Try to find a matching field in retrieved schemas by name\r\n    const matchingRetrieved = retrievedSchemas.find(rs => \r\n      rs.name && field.name && rs.name.toLowerCase() === field.name.toLowerCase()\r\n    );\r\n    \r\n    // If found and it has examples, MERGE THEM INTO THE SCHEMA!\r\n    if (matchingRetrieved && matchingRetrieved.examples && matchingRetrieved.examples.length > 0) {\r\n      return {\r\n        ...field,\r\n        examples: matchingRetrieved.examples,\r\n        description: matchingRetrieved.description || field.description\r\n      };\r\n    }\r\n    return field;\r\n  });\r\n}\r\n\r\nreturn [{\r\n  json: {\r\n    parsedResponse: parsedResponse,\r\n    originalOutput: aiOutput,\r\n    ragEnhanced: buildContext.retrievedExamples > 0,\r\n    schemasUsed: buildContext.retrievedExamples,\r\n    retrievedSchemas: retrievedSchemas\r\n  }\r\n}];\r\n\r\n"
      },
      "position": [
        144,
        -176
      ],
      "typeVersion": 1,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "data-generator",
      "name": "Data Generator (RAG)",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "// Enhanced data generator with RAG schema support\nconst parsedResponse = $input.item.json.parsedResponse;\nconst schema = parsedResponse.schema || [];\nconst recordCount = parsedResponse.recordCount || 100;\nconst message = parsedResponse.message || '';\nconst ragEnhanced = $input.item.json.ragEnhanced;\nconst schemasUsed = $input.item.json.schemasUsed;\nconst retrievedSchemas = $input.item.json.retrievedSchemas || [];\n\n// Enhanced generators with more realistic data\nconst generators = {\n  firstName: () => {\n    const names = ['James', 'Mary', 'John', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda', 'William', 'Elizabeth', 'David', 'Barbara', 'Richard', 'Susan', 'Joseph', 'Jessica', 'Thomas', 'Sarah', 'Christopher', 'Karen', 'Charles', 'Nancy', 'Daniel', 'Lisa', 'Matthew', 'Betty', 'Anthony', 'Helen', 'Mark', 'Sandra'];\n    return names[Math.floor(Math.random() * names.length)];\n  },\n  lastName: () => {\n    const names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Perez', 'Thompson', 'White', 'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson'];\n    return names[Math.floor(Math.random() * names.length)];\n  },\n  email: () => {\n    const first = generators.firstName().toLowerCase();\n    const last = generators.lastName().toLowerCase();\n    const domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'company.com'];\n    return `${first}.${last}@${domains[Math.floor(Math.random() * domains.length)]}`;\n  },\n  phone: () => {\n    const area = Math.floor(Math.random() * 900) + 100;\n    const prefix = Math.floor(Math.random() * 900) + 100;\n    const line = Math.floor(Math.random() * 9000) + 1000;\n    return `(${area}) ${prefix}-${line}`;\n  },\n  uuid: () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  },\n  datetime: () => {\n    const now = new Date();\n    const randomDays = Math.floor(Math.random() * 365);\n    const randomDate = new Date(now.getTime() + (randomDays * 24 * 60 * 60 * 1000));\n    return randomDate.toISOString();\n  },\n  date: () => {\n    const now = new Date();\n    const randomDays = Math.floor(Math.random() * 365);\n    const randomDate = new Date(now.getTime() + (randomDays * 24 * 60 * 60 * 1000));\n    return randomDate.toISOString().split('T')[0];\n  },\n  integer: () => Math.floor(Math.random() * 10000),\n  decimal: () => (Math.random() * 10000).toFixed(2),\n  amount: () => (Math.random() * 10000).toFixed(2),\n  creditCard: () => {\n    const parts = [];\n    for (let i = 0; i < 4; i++) {\n      parts.push(Math.floor(Math.random() * 9000) + 1000);\n    }\n    return parts.join('-');\n  },\n  boolean: () => Math.random() > 0.5,\n  string: () => {\n    const words = ['active', 'pending', 'completed', 'cancelled', 'processing', 'approved', 'rejected', 'draft', 'published', 'archived'];\n    return words[Math.floor(Math.random() * words.length)];\n  }\n};\n\n// Enhanced field value generation using retrieved schemas\nfunction generateIntelligentValue(fieldName, fieldType, retrievedSchemas) {\n  const nameLower = fieldName.toLowerCase();\n  \n  // First, try to find matching field in retrieved schemas\n  const matchingSchema = retrievedSchemas.find(schema => \n    schema.name && schema.name.toLowerCase().includes(nameLower.split('_')[0])\n  );\n  \n  if (matchingSchema && matchingSchema.examples && matchingSchema.examples.length > 0) {\n    // Use examples from retrieved schema\n    return matchingSchema.examples[Math.floor(Math.random() * matchingSchema.examples.length)];\n  }\n  \n  // CRITICAL: Check SPECIFIC patterns BEFORE generic ones!\n  \n  // Flight-specific fields (check FIRST before generic 'number' check!)\n  if (nameLower.includes('flight_number') || nameLower.includes('flight_no') || nameLower.includes('flightnumber')) {\n    const airlines = ['AA', 'UA', 'DL', 'WN', 'B6', 'NK', 'F9', 'AS', 'HA', 'VX'];\n    const airline = airlines[Math.floor(Math.random() * airlines.length)];\n    const flightNum = Math.floor(Math.random() * 9999) + 1;\n    return `${airline}${flightNum}`;\n  }\n  \n  if (nameLower.includes('airport') || nameLower.includes('airport_code')) {\n    const airports = ['LAX', 'JFK', 'ORD', 'DFW', 'DEN', 'ATL', 'SFO', 'SEA', 'LAS', 'MIA', 'PHX', 'IAH', 'MCO', 'BOS', 'DTW', 'MSP', 'PHL', 'LGA', 'BWI', 'DCA'];\n    return airports[Math.floor(Math.random() * airports.length)];\n  }\n  \n  if (nameLower.includes('airline') || nameLower.includes('carrier')) {\n    const airlines = ['AA', 'UA', 'DL', 'WN', 'B6', 'NK', 'F9', 'AS', 'HA', 'VX'];\n    return airlines[Math.floor(Math.random() * airlines.length)];\n  }\n  \n  if (nameLower.includes('seat')) {\n    const rows = Math.floor(Math.random() * 50) + 1;\n    const seats = ['A', 'B', 'C', 'D', 'E', 'F'];\n    const seat = seats[Math.floor(Math.random() * seats.length)];\n    return `${rows}${seat}`;\n  }\n  \n  if (nameLower.includes('flight_status') || nameLower.includes('booking_status')) {\n    const statuses = ['confirmed', 'pending', 'cancelled', 'completed', 'delayed', 'boarding', 'departed', 'arrived'];\n    return statuses[Math.floor(Math.random() * statuses.length)];\n  }\n  \n  // Generic field patterns (check AFTER specific ones)\n  if (nameLower.includes('id')) return generators.uuid();\n  if (nameLower.includes('name')) return generators.firstName() + ' ' + generators.lastName();\n  if (nameLower.includes('email')) return generators.email();\n  if (nameLower.includes('phone')) return generators.phone();\n  if (nameLower.includes('amount') || nameLower.includes('price') || nameLower.includes('fare')) return generators.amount();\n  if (nameLower.includes('date') || nameLower.includes('time')) return generators.datetime();\n  if (nameLower.includes('card')) return generators.creditCard();\n  if (nameLower.includes('status')) return generators.string();\n  if (nameLower.includes('count') || nameLower.includes('number') || nameLower.includes('passenger')) return generators.integer();\n  if (nameLower.includes('active') || nameLower.includes('enabled')) return generators.boolean();\n  \n  // Generic fallback\n  return generators[fieldType] ? generators[fieldType]() : generators.string();\n}\n\nlet data = [];\nfor (let i = 0; i < Math.min(recordCount, 1000); i++) {\n  const record = {};\n  schema.forEach(field => {\n    // ALWAYS use intelligent generation - it checks RAG examples AND has smart fallbacks!\n    record[field.name] = generateIntelligentValue(field.name, field.type, retrievedSchemas);\n  });\n  data.push(record);\n}\n\nreturn [{\n  json: {\n    response: {\n      message: message,\n      data: data,\n      recordCount: data.length,\n      rag_enhanced: ragEnhanced,\n      schemas_used: schemasUsed\n    }\n  }\n}];\n"
      },
      "position": [
        336,
        -176
      ],
      "typeVersion": 1,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "save-log",
      "name": "Save Chat Log",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO chat_logs (session_id, user_prompt, ai_message, generated_schema, generated_data_sample, record_count, success, error_message, user_agent)\nVALUES (\n  '{{ $('Extract Query').item.json.sessionId || 'default' }}',\n  '{{ $('Extract Query').item.json.query.replace(/'/g, \"''\") }}',\n  '{{ $json.response.message.replace(/'/g, \"''\") }}',\n  '{{ JSON.stringify($('Response Parser').item.json.parsedResponse.schema) }}',\n  '{{ JSON.stringify($json.response.data.slice(0, 3)) }}',\n  {{ $json.response.recordCount }},\n  true,\n  NULL,\n  'rag-workflow'\n)\nRETURNING id;",
        "options": {}
      },
      "position": [
        544,
        -176
      ],
      "typeVersion": 2.4,
      "credentials": {
        "postgres": {
          "id": "Qj2oredMBiLhvTqE",
          "name": "Postgres account"
        }
      },
      "webhookId": null
    },
    {
      "id": "feedback-loop",
      "name": "Feedback Loop - Store to Qdrant",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "functionCode": "const response = $input.item.json.response;\r\nconst parsedResponse = $('Response Parser').item.json.parsedResponse;\r\nconst query = $('Extract Query').item.json.query;\r\n\r\nif (!response.rag_enhanced || !parsedResponse.schema || response.data.length === 0) {\r\n  return [$input.item];\r\n}\r\n\r\n// Extract 3-5 examples from generated data for each field\r\nconst enrichedSchema = parsedResponse.schema.map(field => {\r\n  const examples = response.data.slice(0, 5).map(record => record[field.name]).filter(v => v != null);\r\n  return {\r\n    name: field.name,\r\n    type: field.type,\r\n    description: field.description || `Generated field: ${field.name}`,\r\n    examples: examples.length > 0 ? examples : ['sample']\r\n  };\r\n});\r\n\r\nconst domainName = (parsedResponse.message || query).replace(/[^a-zA-Z0-9\\s-]/g, '').trim().substring(0, 50) || 'auto_' + Date.now();\r\n\r\ntry {\r\n  await this.helpers.httpRequest({\r\n    method: 'POST',\r\n    url: 'http://host.docker.internal:5678/webhook/manage-domain-with-registry',\r\n    body: {\r\n      domain: domainName,\r\n      schema: enrichedSchema,\r\n      action: 'create',\r\n      description: `Auto-generated from: ${query}`,\r\n      category: 'Auto-Generated'\r\n    },\r\n    json: true\r\n  });\r\n} catch (error) {\r\n  console.log('Skip:', error.message);\r\n}\r\n\r\nreturn [$input.item];\r\n\r\n"
      },
      "position": [
        544,
        -176
      ],
      "typeVersion": 2,
      "credentials": null,
      "webhookId": null
    },
    {
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Data Generator (RAG)').item.json }}",
        "options": {}
      },
      "position": [
        736,
        -176
      ],
      "typeVersion": 1,
      "credentials": null,
      "webhookId": null
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Query": {
      "main": [
        [
          {
            "node": "Generate Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding": {
      "main": [
        [
          {
            "node": "Search Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Qdrant": {
      "main": [
        [
          {
            "node": "Build Enhanced System Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Enhanced System Message": {
      "main": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent (RAG-Enhanced)": {
      "main": [
        [
          {
            "node": "Response Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent (RAG-Enhanced)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Response Parser": {
      "main": [
        [
          {
            "node": "Data Generator (RAG)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Generator (RAG)": {
      "main": [
        [
          {
            "node": "Feedback Loop - Store to Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Feedback Loop - Store to Qdrant": {
      "main": [
        [
          {
            "node": "Save Chat Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Chat Log": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "528341b2e86c53477b94f918c416779dab805188fc81ebe05aeea5067b309de6"
  }
}
